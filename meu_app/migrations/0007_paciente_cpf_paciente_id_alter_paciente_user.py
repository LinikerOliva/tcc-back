# Generated by Django 4.2.7 on 2025-08-30 17:18

from django.conf import settings
import django.core.validators
from django.db import migrations, models
import django.db.models.deletion
import uuid


TABLE = 'meu_app_paciente'


def ensure_id_column(apps, schema_editor):
    cursor = schema_editor.connection.cursor()
    try:
        cols = [row[1] for row in cursor.execute(f"PRAGMA table_info('{TABLE}')")]
    except Exception:
        cols = []
    if 'id' not in cols:
        cursor.execute(f"ALTER TABLE {TABLE} ADD COLUMN id TEXT")


def gen_paciente_ids_sql(apps, schema_editor):
    cursor = schema_editor.connection.cursor()
    # Preenche somente quando id estiver vazio/nulo
    cursor.execute(f"SELECT user_id, id FROM {TABLE}")
    rows = cursor.fetchall()
    to_update = []
    for user_id, pid in rows:
        if pid is None or pid == '':
            to_update.append((uuid.uuid4().hex, user_id))
    if to_update:
        cursor.executemany(f"UPDATE {TABLE} SET id = ? WHERE user_id = ?", to_update)


def recreate_with_id_pk(apps, schema_editor):
    conn = schema_editor.connection
    cursor = conn.cursor()

    # Verifica se já possui coluna id e se já é PK (então não faz nada)
    info = list(cursor.execute(f"PRAGMA table_info('{TABLE}')"))
    col_names = [c[1] for c in info]
    if 'id' in col_names:
        # Se já existir uma PK chamada 'id', nada a fazer
        for c in info:
            if c[1] == 'id' and c[5] == 1:  # pk flag
                return

    # Coleta colunas atuais e tipos
    columns = [(c[1], c[2], c[3]) for c in info]  # (name, type, notnull)

    # Define DDL para nova tabela
    def col_def(name, typ, notnull):
        # user_id vai deixar de ser NOT NULL, pois será opcional
        if name == 'user_id':
            return f"{name} {typ}"  # sem NOT NULL
        nn = ' NOT NULL' if notnull else ''
        return f"{name} {typ}{nn}"

    # Mantém todas as colunas existentes exceto eventuais 'id' antigas
    existing_cols = [c for c in columns if c[0] != 'id']

    # Monta DDL com id TEXT PK + colunas existentes
    ddl_cols = ["id TEXT PRIMARY KEY"] + [col_def(name, typ or 'TEXT', notnull) for name, typ, notnull in existing_cols]

    # Garante UNIQUE(user_id)
    unique_user = ", UNIQUE(user_id)" if any(name == 'user_id' for name, _, _ in existing_cols) else ''

    cursor.execute("PRAGMA foreign_keys=OFF")
    try:
        cursor.execute(f"CREATE TABLE {TABLE}__new ({', '.join(ddl_cols)}{unique_user})")
        # Copia os dados (usa somente colunas comuns)
        src_cols = ['id'] + [name for name, _, _ in existing_cols]
        col_list = ', '.join(src_cols)
        cursor.execute(f"INSERT INTO {TABLE}__new ({col_list}) SELECT {col_list} FROM {TABLE}")
        cursor.execute(f"DROP TABLE {TABLE}")
        cursor.execute(f"ALTER TABLE {TABLE}__new RENAME TO {TABLE}")
    finally:
        cursor.execute("PRAGMA foreign_keys=ON")


class Migration(migrations.Migration):

    dependencies = [
        ('meu_app', '0006_consulta_assinada_em_consulta_assinada_por_and_more'),
    ]

    operations = [
        # 1) Adiciona CPF (permite nulo, único) - seguro para dados existentes
        migrations.AddField(
            model_name='paciente',
            name='cpf',
            field=models.CharField(
                blank=True,
                max_length=14,
                null=True,
                unique=True,
                validators=[
                    django.core.validators.RegexValidator(
                        message='CPF deve estar no formato XXX.XXX.XXX-XX',
                        regex='^\\d{3}\\.\\d{3}\\.\\d{3}-\\d{2}$',
                    )
                ],
            ),
        ),
        # 2) Garante coluna 'id' e preenche valores
        migrations.RunPython(ensure_id_column, migrations.RunPython.noop),
        migrations.RunPython(gen_paciente_ids_sql, migrations.RunPython.noop),
        # 3) Recria a tabela com 'id' como PK e user_id UNIQUE
        migrations.RunPython(recreate_with_id_pk, migrations.RunPython.noop),
        # 4) Atualiza SOMENTE o estado para refletir o novo esquema
        migrations.SeparateDatabaseAndState(
            database_operations=[],
            state_operations=[
                migrations.AlterField(
                    model_name='paciente',
                    name='user',
                    field=models.OneToOneField(
                        blank=True,
                        null=True,
                        on_delete=django.db.models.deletion.CASCADE,
                        to=settings.AUTH_USER_MODEL,
                    ),
                ),
                migrations.AddField(
                    model_name='paciente',
                    name='id',
                    field=models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False, serialize=False),
                ),
            ],
        ),
    ]
